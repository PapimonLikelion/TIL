### 2022-07-10

*참고: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard*
## 인프링 시큐리티 일반 로그
- **모든 주소가 막힌다**
  - 스프링 시큐리티를 쓴다면 기본적으로 모든 주소가 막혀 인증이 필요해짐
  - localhost:8080/login
  - 최초 아이디: user, 비밀번호: 스프링 뜰 때 비밀번호

- **인증을 완료하면 그제서야 Controller API 호출 가능**
  - GET: /login => 이거 만들어도 스프링 시큐리티가 낚아챔
    - `SecurityConfig` 파일 만들면 login Controller로 흘러들어감

- **SecurityConfig Bean 정의하기**
  ```java
  @Configuration
  @EnableWebSecurity // 스프링 시큐리티 필터가 스프링 필터체인에 등록됨
  public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http.csrf().disable();
          http.authorizeRequests()
                  // 이 세가지 주소가 아니면
                  .antMatchers("/user/**").authenticated()
                  .antMatchers("/manager/**").access("hasRole('ROLE_ADMIN' or hasRole('ROLE_MANAGER')")
                  .antMatchers("/admin/**").access("hasRole('ROLE_ADMIN)")
                  // 누구나 들어갈 수 있다
                  .anyRequest().permitAll()
                  // 권한이 없는 페이지로 이동하려고 할 때 로그인을 받아야겠지?
                  .and()
                  .formLogin()
                  .loginPage("/login");
      }
  }
  ```

- **패스워드 인코딩**
  ```java
  @Configuration
  @EnableWebSecurity // 스프링 시큐리티 필터가 스프링 필터체인에 등록됨
  public class SecurityConfig extends WebSecurityConfigurerAdapter {
      @Bean
      public BCryptPasswordEncoder encodePwd() {
        return new BCryptPasswordEncoder();
      }
  }
  ```

- **시큐리티 로그인**
  ```java
  @Configuration
  @EnableWebSecurity // 스프링 시큐리티 필터가 스프링 필터체인에 등록됨
  @EnableGlobalMethodSecurity(securedEnabled = true) // @Secured 어노테이션 활성화! Controller에서 @Secured("ROLE_ADMIN")
  @EnableGlobalMethodSecurity(prePostEnabled = true) // @PreAuthorize, @PostAuthorize 어노테이션 활성화! Controller에서 @PreAuthorized("hasRole('ROLE_MANAGER') or hasRole('ROLE_ADMIN')")
  public class SecurityConfig extends WebSecurityConfigurerAdapter {
  
      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http.csrf().disable();
          http.authorizeRequests()
                  // 이 세가지 주소가 아니면
                  .antMatchers("/user/**").authenticated() // 인증만 되면 들어갈 수 있어
                  .antMatchers("/manager/**").access("hasRole('ROLE_ADMIN' or hasRole('ROLE_MANAGER')")
                  .antMatchers("/admin/**").access("hasRole('ROLE_ADMIN)")
                  // 누구나 들어갈 수 있다
                  .anyRequest().permitAll()
                  // 권한이 없는 페이지로 이동하려고 할 때 로그인을 받아야겠지?
                  .and()
                  .formLogin()
                  .loginPage("/login")
                  .loginProcessingUrl("/login") // login 주소가 호출이 되면 시큐리티가 낚아채서 대신 로그인 진행
                  .defaultSuccessUrl("/");
      }
  }
  ```
  - 시큐리티 /login 주소 요청이 오면 낚아채서 로그인을 진행시킴
  - 로그인을 진행이 완료가 되면 시큐리티 session을 만들어줍니다
  - 오브젝트 => Authentication 타입 객체 => Authentication 안에 User 정보가 있어야 함
    - UserDetails 타입 객체로 지정되어 있음
  - SecuritySession => Authentication => UserDetails 타입이여야 함
  ```java
  // PrincipalDetails를 UserDetails에 넣을 수 있
  public class PrincipalDetails implements UserDetails {
      private User user;
      
      public PrincipalDetails(User user) {
          this.user = user;
      }
      
      @Override
      public Collection<? extends GrantedAuthority> getAuthorities() {
          Collection<GrantedAuthority> collect = new ArrayList<>();
          collect.add(new GrantedAuthority() {
              @Override
              public String getAuthority() {
                  return user.getRole();
              }
          });
          return collect;
      }
      
      @Override 
      public String getPassword() {
          return user.getPassword();
      }
        
      @Override
      public String getUsername() {
        return user.getUsername();
      }
      
      // 기타 등등... 활성화 여부, expire 여부 등등...
  }
  ```
  - 자, 이번엔 authentication 객체는 어떻게 만드는가?
  ```java
  // 시큐리티 설정에서 loginProcessingUrl("/login");
  // login 요청이 오면 자동으로 UserDetailsService 타입으로 IoC 되어있는 loadUserByUsername 함수 실행
  @Service
  public class PrincipalDetailsService implements UserDetailService {
        
      @Autowired
      private UserRepository userRepository;
  
      // 시큐리티 Session = Authentication = UserDetails
      @Override
      public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
          User userEntity = userRepository.findByUsername(username);
          if (userEntity != null) {
              return new PrincipalDetails(userEntity);
          }
          return null;
      }
  }
  ```

### 인프런 스프링 시큐리티 OAuth
- **시큐리티 OAuth**
  ```java
  @Configuration
  @EnableWebSecurity // 스프링 시큐리티 필터가 스프링 필터체인에 등록됨
  @EnableGlobalMethodSecurity(securedEnabled = true) // @Secured 어노테이션 활성화! Controller에서 @Secured("ROLE_ADMIN")
  @EnableGlobalMethodSecurity(prePostEnabled = true) // @PreAuthorize, @PostAuthorize 어노테이션 활성화! Controller에서 @PreAuthorized("hasRole('ROLE_MANAGER') or hasRole('ROLE_ADMIN')")
  public class SecurityConfig extends WebSecurityConfigurerAdapter {
  
      @Autowired
      private PrincipalOauth2UserService principalOauth2UserService;
  
      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http.csrf().disable();
          http.authorizeRequests()
                  // 이 세가지 주소가 아니면
                  .antMatchers("/user/**").authenticated() // 인증만 되면 들어갈 수 있어
                  .antMatchers("/manager/**").access("hasRole('ROLE_ADMIN' or hasRole('ROLE_MANAGER')")
                  .antMatchers("/admin/**").access("hasRole('ROLE_ADMIN)")
                  // 누구나 들어갈 수 있다
                  .anyRequest().permitAll()
                  // 권한이 없는 페이지로 이동하려고 할 때 로그인을 받아야겠지?
                  .and()
                  .formLogin()
                  .loginPage("/login")
                  .loginProcessingUrl("/login") // login 주소가 호출이 되면 시큐리티가 낚아채서 대신 로그인 진행
                  .defaultSuccessUrl("/")
                  .and()
                  .oauth2Login()
                  .loginPage("/loginForm") // 구글 로그인 완료된 후 후처리가 필요하다 1. 코드받기(인증) => 2. 액세스토큰(권한) => 3. 사용자 프로필 정보 가져오고 => 4. 그 정보 토대로 회원가입 자동 진행
                  .userInfoEndpoint()
                  .userService(principalOauth2UserService);
      }
  }
  
  @Service
  public class PrincipalOauth2UserService extends DefaultOAuth2UserService {
      @Override
      public OAuth2User loadUser(OAuth2UserRequest userRequest) {
          return super.loadUser(userRequest);
      }
  }
  
  @Controller
  public class UserController {
    // 그냥 회원가입한 유저
    @GetMapping("/test/login")
    public @ResponseBody String testLogin(Authentication authentication, 
                                          @AuthenticationPrincipal PrincipalDetails userDetails) {
        System.out.println("/test/login ====== ");
        PrincipalDetails principalDetails = (PrincipalDetails) authentication.getPrincipal();
        System.out.println("authentication : " + principalDetails.getUser());
        System.out.println("userDetails : " + userDetails.getUsername());
        return "세션 정보 확인하기";
    }
  
    @GetMapping("/test/oauth/login")
    public @ResponseBody String testOAuthLogin(Authentication authentication, 
                                               @AuthenticationPrincipal OAuth2User oauth) {
        System.out.println("/test/oauth/login ====== ");
        OAuth2User oAuth2User = (OAuth2User) authentication.getPrincipal();
        System.out.println("authentication : " + oAuth2User.getAttributes());
        System.out.println("oauth2User : " + oauth.getAttributes());
        return "OAuth 세션 정보 확인";
    }
  }
  ```

- **정리**
  - 스프링 시큐리티는 자신만의 세션을 들고 있어
  - 여기 안에 들어갈 수 있는 타입은 Authentication 객체 밖에 없음
    - 이걸 DI 할 수 있음
    - 해당 객체는 두가지 타입이 있음
      - UserDetails : 일반 로그인
      - OAuth2User : OAuth 로그인
    - 요게 들어가 있어야 로그인 처리가 되는 거임 
  - 필요할 때 꺼내써야 하는데 일반 로그인, OAuth 로그인 둘 다 지원해야하는데...?
    - 따라서 추상화를 시키자!
      - UserDetails와 OAuth2User 두 가지를 모두 상속받은 것
  ```java
  @Data
  public class PrincipalDetails implements UserDetails, OAuth2User {
      
  }
  ```