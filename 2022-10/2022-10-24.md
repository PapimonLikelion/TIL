### 2022-10-24

## Spring vs SpringBoot
- **설명**
  - 스프링 부트는 단지 실행만 하면 되는 스프링 기반의 어플리케이션을 쉽게 만들 수 있다
  - 원래 스프링은... xml로 복잡하게 내용들을 다 작성해줘야해
    - 모든 dependency 버전까지 하나하나 정확하게!

- **AutoConfiguration을 활용한 스프링 부트**
  - 어플리케이션 개발에 필요한 모든 Dependency를 프레임워크에서 관리
  - jar 파일이 클래스 패스에 있는 경우 스프링 부트는 Dispatcher Servlet으로 자동 구성
  - 스프링 부트는 미리 설정되어있는 starter 프로젝트를 제공
  - SpringBoot-Starter를 제공하여 자동으로 호환되는 버전을 알아서 관리 => 패키지 디펜던시
    - spring-boot-starter-web
    - spring-boot-starter-test
    - spring-boot-starter-data-jpa
    - spring-boot-starter-jdbc
    - spring-boot-starter-security
  - xml 설정 없이 자바 코드를 통해 설정할 수 있음

- **`@SpringBootApplication`**
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
}
```

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
@Indexed
public @interface SpringBootConfiguration {
}
```

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {
}
```

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(AutoConfigurationPackages.Registrar.class)
public @interface AutoConfigurationPackage {
}
```

## SpringApplication.run() => ApplicationContext 생성 및 구동
1. 일단 psvm에서 본인의 클래스 class를 변수로 두고 정적 메서드로 실행을 시킨다 
   - SpringApplication : 자바 메인 메서드에서 부트스트랩 시켜 실행시킬 수 있는 클래스
     - 알맞은 ApplicationContext 객체를 생성
     - CommandLinePropertySource를 통해 CommandLine에 있는 친구들 실행
     - ApplicationContext를 리프레시 하고 모든 Singleton 빈들을 로딩하기
     - 모든 CommandLineRunner 빈들 실행
  ```java
  public static void main(String[] args) {
      SpringApplication.run(ConnectableApplication.class, args);
  }
  ```

2. SpringApplication 클래스 안에서 새로운 SpringApplication 객체 만들고 run!
  ```java
  public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
      return new SpringApplication(primarySources).run(args);
  }
  ```

3. run() 메서드는 다음과 같음
   - ConfigurableApplicationContext 타입의 ApplicationContext 생성하는 과정!
   - AnnotationConfigApplicationContext 타입이 대입되게 됨
   - refreshContext(context)를 통해 각각 구동에 필요한 빈들의 설정들이 적용되고 등록됨
  ```java
  public ConfigurableApplicationContext run(String... args) {
      long startTime = System.nanoTime();
      DefaultBootstrapContext bootstrapContext = createBootstrapContext();
      ConfigurableApplicationContext context = null;
      configureHeadlessProperty();
      SpringApplicationRunListeners listeners = getRunListeners(args);
      listeners.starting(bootstrapContext, this.mainApplicationClass);
      try {
          ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
          ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);
          configureIgnoreBeanInfo(environment);
          Banner printedBanner = printBanner(environment);
          context = createApplicationContext(); // 4번
          context.setApplicationStartup(this.applicationStartup);
          prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);
          refreshContext(context); // 5번
          afterRefresh(context, applicationArguments);
          Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);
          if (this.logStartupInfo) {
              new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup);
          }
          listeners.started(context, timeTakenToStartup);
          callRunners(context, applicationArguments);
      }
      catch (Throwable ex) {
          handleRunFailure(context, ex, listeners);
          throw new IllegalStateException(ex);
      }
      try {
          Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);
          listeners.ready(context, timeTakenToReady);
      }
      catch (Throwable ex) {
          handleRunFailure(context, ex, null);
          throw new IllegalStateException(ex);
      }
      return context;
  }
  ```

4. createApplicationContext()은 기본으로 AnnotationConfigApplicationContext 방식으로 생성함
  ```java
  public AnnotationConfigApplicationContext() {
      StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start("spring.context.annotated-bean-reader.create");
      this.reader = new AnnotatedBeanDefinitionReader(this);
      createAnnotatedBeanDefReader.end();
      this.scanner = new ClassPathBeanDefinitionScanner(this);
  }
  ```

5. refreshContext(context)에서 다음 설정들이 다들 적용됨
   - Repository 레이어 초기화 진행
     - Redis, JPA 스캔하면서 설정한 모드에 따라 초기화
   - 톰캣(서블릿 엔진)도 초기화 : 8080 포트로 띄우기
     - 쓰레드 풀도 열어두고!
   - 히카리풀도 초기화 : 데이터베이스 연결하기
   - JPAEntityManagerFactory도 초기화!
   - OSIV도 설정 열어두고...
   - SecurityFilterChain도 등록해주고!
  ```
  14:04:44.891 [INFO ] [restartedMain] [o.s.d.r.c.RepositoryConfigurationDelegate] - Multiple Spring Data modules found, entering strict repository configuration mode
  14:04:44.896 [INFO ] [restartedMain] [o.s.d.r.c.RepositoryConfigurationDelegate] - Bootstrapping Spring Data Redis repositories in DEFAULT mode.
  14:04:45.157 [INFO ] [restartedMain] [o.s.d.r.c.RepositoryConfigurationDelegate] - Finished Spring Data repository scanning in 98 ms. Found 0 Redis repository interfaces.
  14:04:50.067 [INFO ] [restartedMain] [o.s.d.r.c.RepositoryConfigurationDelegate] - Multiple Spring Data modules found, entering strict repository configuration mode
  14:04:50.068 [INFO ] [restartedMain] [o.s.d.r.c.RepositoryConfigurationDelegate] - Bootstrapping Spring Data JPA repositories in DEFAULT mode.
  14:04:52.107 [INFO ] [restartedMain] [o.s.d.r.c.RepositoryConfigurationExtensionSupport] - Spring Data JPA - Could not safely identify store assignment for repository candidate interface com.backend.connectable.user.redis.UserTicketEntranceRedisRepository; If you want this repository to be a JPA repository, consider annotating your entities with one of these annotations: javax.persistence.Entity, javax.persistence.MappedSuperclass (preferred), or consider extending one of the following types with your repository: org.springframework.data.jpa.repository.JpaRepository
  14:04:52.764 [INFO ] [restartedMain] [o.s.d.r.c.RepositoryConfigurationDelegate] - Finished Spring Data repository scanning in 2667 ms. Found 7 JPA repository interfaces.
  14:04:52.951 [INFO ] [restartedMain] [o.s.d.r.c.RepositoryConfigurationDelegate] - Multiple Spring Data modules found, entering strict repository configuration mode
  14:04:52.952 [INFO ] [restartedMain] [o.s.d.r.c.RepositoryConfigurationDelegate] - Bootstrapping Spring Data Redis repositories in DEFAULT mode.
  14:05:00.290 [INFO ] [restartedMain] [o.s.cloud.context.scope.GenericScope] - BeanFactory id=2fa6ef28-6c1c-3e6f-a9d4-84a4731e7c62
  14:05:15.633 [INFO ] [restartedMain] [o.s.b.w.e.tomcat.TomcatWebServer] - Tomcat initialized with port(s): 8080 (http)
  14:05:15.811 [INFO ] [restartedMain] [o.a.coyote.http11.Http11NioProtocol] - Initializing ProtocolHandler ["http-nio-8080"]
  14:05:15.813 [INFO ] [restartedMain] [o.a.catalina.core.StandardService] - Starting service [Tomcat]
  14:05:15.814 [INFO ] [restartedMain] [o.a.catalina.core.StandardEngine] - Starting Servlet engine: [Apache Tomcat/9.0.64]
  14:05:18.247 [INFO ] [restartedMain] [o.a.c.c.C.[Tomcat].[localhost].[/]] - Initializing Spring embedded WebApplicationContext
  14:05:18.248 [INFO ] [restartedMain] [o.s.b.w.s.c.ServletWebServerApplicationContext] - Root WebApplicationContext: initialization completed in 54183 ms
  14:05:19.493 [INFO ] [restartedMain] [com.zaxxer.hikari.HikariDataSource] - HikariPool-1 - Starting...
  14:05:21.290 [INFO ] [restartedMain] [com.zaxxer.hikari.HikariDataSource] - HikariPool-1 - Start completed.
  14:05:21.426 [INFO ] [restartedMain] [o.s.b.a.h.H2ConsoleAutoConfiguration] - H2 console available at '/h2-console'. Database available at 'jdbc:h2:mem:connectable'
  14:05:25.298 [INFO ] [restartedMain] [o.h.jpa.internal.util.LogHelper] - HHH000204: Processing PersistenceUnitInfo [name: default]
  14:05:25.942 [INFO ] [restartedMain] [org.hibernate.Version] - HHH000412: Hibernate ORM core version 5.6.9.Final
  14:05:27.876 [INFO ] [restartedMain] [o.h.annotations.common.Version] - HCANN000001: Hibernate Commons Annotations {5.1.2.Final}
  14:05:29.209 [INFO ] [restartedMain] [org.hibernate.dialect.Dialect] - HHH000400: Using dialect: org.hibernate.dialect.H2Dialect
  
  14:05:38.954 [INFO ] [restartedMain] [o.h.e.t.j.p.i.JtaPlatformInitiator] - HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
  14:05:39.037 [INFO ] [restartedMain] [o.s.o.j.LocalContainerEntityManagerFactoryBean] - Initialized JPA EntityManagerFactory for persistence unit 'default'
  14:06:17.568 [WARN ] [restartedMain] [o.s.b.a.o.j.JpaBaseConfiguration$JpaWebConfiguration] - spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
  14:06:21.534 [INFO ] [restartedMain] [o.s.b.d.a.OptionalLiveReloadServer] - LiveReload server is running on port 35729
  14:06:37.304 [INFO ] [restartedMain] [o.s.s.web.DefaultSecurityFilterChain] - Will secure any request with [org.springframework.security.web.session.DisableEncodeUrlFilter@4f3eb020, org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@4eecf606, org.springframework.security.web.context.SecurityContextPersistenceFilter@3a6f3601, org.springframework.security.web.header.HeaderWriterFilter@62216031, org.springframework.security.web.authentication.logout.LogoutFilter@39257525, com.backend.connectable.security.custom.JwtAuthenticationFilter@7235c6ae, org.springframework.security.web.savedrequest.RequestCacheAwareFilter@1493436d, org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@1afbaa27, org.springframework.security.web.authentication.AnonymousAuthenticationFilter@7d5440a4, org.springframework.security.web.session.SessionManagementFilter@9e89d5a, org.springframework.security.web.access.ExceptionTranslationFilter@742c305f, org.springframework.security.web.access.intercept.FilterSecurityInterceptor@7214c6c8]
  14:06:46.967 [INFO ] [restartedMain] [o.a.coyote.http11.Http11NioProtocol] - Starting ProtocolHandler ["http-nio-8080"]
  14:06:47.144 [INFO ] [restartedMain] [o.s.b.w.e.tomcat.TomcatWebServer] - Tomcat started on port(s): 8080 (http) with context path ''
  ```

6. 다음과 같이 생성된 Context 반환
  ```
  context = {AnnotationConfigServletWebServerApplicationContext@6428} "org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@227f5c14, started on Mon Oct 24 14:15:01 KST 2022"
  - reader = {AnnotatedBeanDefinitionReader@16464} 
  - scanner = {ClassPathBeanDefinitionScanner@16465} 
  - annotatedClasses = {LinkedHashSet@16466}  size = 0
  - basePackages = null
  - webServer = {TomcatWebServer@16467} 
  - servletConfig = null
  - serverNamespace = null
  - servletContext = {ApplicationContextFacade@16468} 
  - themeSource = {ResourceBundleThemeSource@16469} 
  - beanFactory = {DefaultListableBeanFactory@16470} "org.springframework.beans.factory.support.DefaultListableBeanFactory@d333d97: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.internalPersistenceAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,connectableApplication,org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory,adminIssueService,adminOrderService,adminService,adminController,artistService,artistController,authService,authController,eventRepositoryImpl,ticketRepositoryImpl,eventService,eventController,globalExceptionHandler,timeCheckAspect,resourceHandlerConfig,swaggerConfig,workaround,restTemplateClient,redisDao,embeddedRedisConfig,redisConfig,kasWebClient,kasWebClientConfigur"
  - resourceLoader = {ClassLoaderFilesResourcePatternResolver@16471} 
  - customClassLoader = false
  - refreshed = {AtomicBoolean@16472} "true"
  - logger = {LogAdapter$Slf4jLocationAwareLog@16473} 
  - id = "application"
  - displayName = "org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@227f5c14"
  - parent = null
  - environment = {ApplicationServletEnvironment@6299} "ApplicationServletEnvironment {activeProfiles=[local, console-logging], defaultProfiles=[default], propertySources=[MapPropertySource {name='server.ports'}, ConfigurationPropertySourcesPropertySource {name='configurationProperties'}, StubPropertySource {name='servletConfigInitParams'}, ServletContextPropertySource {name='servletContextInitParams'}, PropertiesPropertySource {name='systemProperties'}, OriginAwareSystemEnvironmentPropertySource {name='systemEnvironment'}, RandomValuePropertySource {name='random'}, CachedRandomPropertySource {name='cachedrandom'}, AwsParamStorePropertySource {name='/config/connectable_console-logging/'}, AwsParamStorePropertySource {name='/config/connectable_local/'}, AwsParamStorePropertySource {name='/config/connectable/'}, AwsParamStorePropertySource {name='/config/application_console-logging/'}, AwsParamStorePropertySource {name='/config/application_local/'}, AwsParamStorePropertySource {name='/config/application/'}, OriginTrackedMapPropertySource {nam"
  - beanFactoryPostProcessors = {ArrayList@16476}  size = 3
  - startupDate = 1666588501271
  - active = {AtomicBoolean@16477} "true"
  - closed = {AtomicBoolean@16478} "false"
  - startupShutdownMonitor = {Object@16479} 
  - shutdownHook = null
  - resourcePatternResolver = {ServletContextResourcePatternResolver@16480} 
  - lifecycleProcessor = {DefaultLifecycleProcessor@16481} 
  - messageSource = {DelegatingMessageSource@16482} "Empty MessageSource"
  - applicationEventMulticaster = {SimpleApplicationEventMulticaster@16483} 
  - applicationStartup = {DefaultApplicationStartup@2416} 
  - applicationListeners = {LinkedHashSet@16484}  size = 53
  - earlyApplicationListeners = {LinkedHashSet@16485}  size = 17
  - earlyApplicationEvents = null
  - classLoader = null
  - protocolResolvers = {LinkedHashSet@16486}  size = 0
  - resourceCaches = {ConcurrentHashMap@16487}  size = 0
  ```

7. Bean Factory에 등록된 Bean들 (엄청많음...)
    ```
    org.springframework.beans.factory.support.DefaultListableBeanFactory@d333d97: defining beans [
    org.springframework.context.annotation.internalConfigurationAnnotationProcessor,
    org.springframework.context.annotation.internalAutowiredAnnotationProcessor,
    org.springframework.context.annotation.internalCommonAnnotationProcessor,
    org.springframework.context.annotation.internalPersistenceAnnotationProcessor,
    org.springframework.context.event.internalEventListenerProcessor,
    org.springframework.context.event.internalEventListenerFactory,
    
    // 어플리케이션
    connectableApplication,
    
    org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory,
    
    // 내가 정의한 빈들
    adminIssueService, adminOrderService, adminService, adminController, artistService, artistController, authService, authController,
    eventRepositoryImpl, ticketRepositoryImpl, eventService, eventController, globalExceptionHandler, timeCheckAspect, resourceHandlerConfig, 
    swaggerConfig, workaround, restTemplateClient, redisDao, embeddedRedisConfig, redisConfig, kasWebClient, kasWebClientConfiguration, 
    kasService, kasEndPointGenerator, kasContractService, transactionOptionManager, kasTokenService, klipService, orderRepositoryImpl, 
    orderService, orderController, s3Service, scheduledTasks, securityConfiguration, webConfiguration, customUserDetailsService, 
    jwtAuthenticationFilter, jwtProvider, smsConfig, smsService, userRepositoryImpl, userService, userTicketService, userController, 
    openApiControllerWebMvc, oasVendorExtensionsMapperImpl, styleEnumMapperImpl, securitySchemeMapperImpl, oasSecurityMapperImpl, 
    
    // 수많은 Swagger 관련 빈들
    schemaMapperImpl, examplesMapperImpl, serviceModelToOpenApiMapperImpl, oasLicenceMapper, apiListingReferenceScanner, apiDocumentationScanner, 
    apiDescriptionReader, apiListingReader, apiModelSpecificationReader, cachingOperationReader, mediaTypeReader, apiListingScanner, 
    apiModelReader, apiDescriptionLookup, operationModelsProvider, operationDeprecatedReader, responseMessagesReader, operationParameterReader, 
    operationTagsReader, apiOperationReader, defaultOperationReader, operationParameterRequestConditionReader, operationParameterHeadersConditionReader, 
    
    // ViewResolver, ObjectMapper, Jackson, Parameter 변환기 등 여러가지 요청/응답에 대한 처리를 위한 빈들
    contentParameterAggregator, operationResponseClassReader, cachingOperationNameGenerator, parameterMultiplesReader, modelAttributeParameterExpander, 
    parameterTypeReader, parameterRequiredReader, parameterDataTypeReader, parameterDefaultReader, parameterNameReader, expandedParameterBuilder, 
    webMvcRequestHandlerProvider, defaultResponseTypeReader, documentationPluginsBootstrapper, documentationPluginsManager, 
    queryStringUriTemplateDecorator, pathMappingDecorator, pathSanitizer, operationPathDecorator, jacksonJsonViewProvider, 
    cachingModelDependencyProvider, typeNameExtractor, propertyDiscriminatorBasedInheritancePlugin, xmlModelPlugin, schemaPluginsManager, 
    jsonIgnorePropertiesModelPlugin, cachingModelPropertiesProvider, objectMapperBeanPropertyNamingStrategy, accessorsProvider, fieldProvider, 
    xmlPropertyPlugin, optimized, factoryMethodProvider, modelSpecificationFactory, cachingModelProvider, defaultModelDependencyProvider, 
    jacksonEnumTypeDeterminer, defaultModelProvider, defaultModelSpecificationProvider, openApiSchemaPropertyBuilder, 
    apiModelPropertyPropertyBuilder, apiModelTypeNameProvider, apiModelBuilder, operationImplicitParameterReader, vendorExtensionsReader, 
    
    // Swagger 설정
    swaggerOperationResponseClassReader, swaggerOperationModelsProvider, openApiOperationAuthReader, 
    swaggerMediaTypeReader, operationHttpMethodReader, operationImplicitParametersReader, operationAuthReader, 
    operationHiddenReader, operationSummaryReader, openApiOperationTagsReader, swaggerResponseMessageReader, 
    operationNicknameIntoUniqueIdReader, operationPositionReader, openApiResponseReader, operationNotesReader, 
    swaggerOperationTagsReader, swaggerParameterDescriptionReader, swaggerExpandedParameterBuilder, openApiParameterBuilder, 
    swaggerApiListingReader, inMemorySwaggerResourcesProvider, apiResourceController, serviceModelToSwagger2MapperImpl, 
    vendorExtensionsMapperImpl, propertyMapperImpl, compatibilityModelMapperImpl, parameterMapperImpl, modelMapperImpl, 
    requestParameterMapperImpl, modelSpecificationMapperImpl, licenseMapperImpl, securityMapperImpl, swagger2ControllerWebMvc, 
    
    // 핸들러 매핑, ViewResolver 등의 Spring MVC flow에 필요한 빈들
    org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration, 
    requestMappingHandlerMapping, mvcPatternParser, mvcUrlPathHelper, mvcPathMatcher, mvcContentNegotiationManager, viewControllerHandlerMapping, 
    beanNameHandlerMapping, routerFunctionMapping, resourceHandlerMapping, mvcResourceUrlProvider, defaultServletHandlerMapping, requestMappingHandlerAdapter, 
    handlerFunctionAdapter, mvcConversionService, mvcValidator, mvcUriComponentsContributor, httpRequestHandlerAdapter, 
    simpleControllerHandlerAdapter, handlerExceptionResolver, mvcViewResolver, mvcHandlerMappingIntrospector, localeResolver, 
    themeResolver, flashMapManager, viewNameTranslator, parseApi, redisConnectionFactory, 
    
    // Redis 관련 설정들
    org.springframework.data.redis.repository.configuration.RedisRepositoryConfigurationExtension#0, keyValueMappingContext, 
    redisCustomConversions, redisReferenceResolver, redisConverter, redisKeyValueAdapter, redisKeyValueTemplate, webClientForKas, redisTemplate,
    
    // 수많은 Configuration들... Jackson, Servlet, WebMvc, Security, Codec, Validation, AOP 등등...
    org.springframework.security.config.annotation.configuration.ObjectPostProcessorConfiguration, objectPostProcessor, 
    org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration, authenticationManagerBuilder, 
    enableGlobalAuthenticationAutowiredConfigurer, initializeUserDetailsBeanManagerConfigurer, initializeAuthenticationProviderBeanManagerConfigurer, 
    org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration, delegatingApplicationListener, 
    webSecurityExpressionHandler, springSecurityFilterChain, privilegeEvaluator, conversionServicePostProcessor, 
    org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration, requestDataValueProcessor, 
    org.springframework.security.config.annotation.web.configuration.HttpSecurityConfiguration, 
    org.springframework.security.config.annotation.web.configuration.HttpSecurityConfiguration.httpSecurity, initMessageService, 
    org.springframework.scheduling.annotation.SchedulingConfiguration, 
    org.springframework.context.annotation.internalScheduledAnnotationProcessor, 
    org.springframework.context.config.internalBeanConfigurerAspect, jpaAuditingHandler, jpaMappingContext, 
    org.springframework.boot.autoconfigure.AutoConfigurationPackages, 
    org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration, propertySourcesPlaceholderConfigurer, 
    org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration$TomcatWebSocketConfiguration, websocketServletWebServerCustomizer, 
    org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration, 
    org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryConfiguration$EmbeddedTomcat, tomcatServletWebServerFactory, 
    org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration, servletWebServerFactoryCustomizer, tomcatServletWebServerFactoryCustomizer, 
    org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor, 
    org.springframework.boot.context.internalConfigurationPropertiesBinderFactory, 
    org.springframework.boot.context.internalConfigurationPropertiesBinder, 
    org.springframework.boot.context.properties.BoundConfigurationProperties, 
    org.springframework.boot.context.properties.EnableConfigurationPropertiesRegistrar.methodValidationExcludeFilter, 
    server-org.springframework.boot.autoconfigure.web.ServerProperties, webServerFactoryCustomizerBeanPostProcessor, errorPageRegistrarBeanPostProcessor, 
    org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration$DispatcherServletConfiguration, dispatcherServlet, 
    spring.mvc-org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties, 
    org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration$DispatcherServletRegistrationConfiguration, dispatcherServletRegistration, 
    org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration, 
    org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$Jackson2ObjectMapperBuilderCustomizerConfiguration, 
    standardJacksonObjectMapperBuilderCustomizer, spring.jackson-org.springframework.boot.autoconfigure.jackson.JacksonProperties, 
    org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperBuilderConfiguration, jacksonObjectMapperBuilder, 
    org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$ParameterNamesModuleConfiguration, parameterNamesModule, 
    org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperConfiguration, jacksonObjectMapper, 
    org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration, jsonComponentModule, jsonMixinModule, 
    org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration$DefaultCodecsConfiguration, defaultCodecCustomizer, 
    org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration$JacksonCodecConfiguration, jacksonCodecCustomizer, 
    org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration, spring.codec-org.springframework.boot.autoconfigure.codec.CodecProperties, 
    org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration, defaultValidator, methodValidationPostProcessor, 
    org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration, taskExecutorBuilder, applicationTaskExecutor, 
    spring.task.execution-org.springframework.boot.autoconfigure.task.TaskExecutionProperties, 
    org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration$WhitelabelErrorViewConfiguration, error, beanNameViewResolver, 
    org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration$DefaultErrorViewResolverConfiguration, conventionErrorViewResolver, 
    spring.web-org.springframework.boot.autoconfigure.web.WebProperties, 
    org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration, errorAttributes, basicErrorController, errorPageCustomizer, preserveErrorControllerTargetClassPostProcessor, 
    org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration, mbeanExporter, objectNamingStrategy, mbeanServer, 
    spring.jmx-org.springframework.boot.autoconfigure.jmx.JmxProperties, 
    org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration, springApplicationAdminRegistrar, 
    org.springframework.boot.autoconfigure.aop.AopAutoConfiguration$AspectJAutoProxyingConfiguration$CglibAutoProxyConfiguration, 
    org.springframework.aop.config.internalAutoProxyCreator, org.springframework.boot.autoconfigure.aop.AopAutoConfiguration$AspectJAutoProxyingConfiguration, 
    org.springframework.boot.autoconfigure.aop.AopAutoConfiguration, 
    org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration, applicationAvailability, 
    org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration, 
    org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Hikari, dataSource, 
    org.springframework.boot.autoconfigure.jdbc.DataSourceJmxConfiguration$Hikari, 
    org.springframework.boot.autoconfigure.jdbc.DataSourceJmxConfiguration, 
    org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration$PooledDataSourceConfiguration, 
    org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration$HikariPoolDataSourceMetadataProviderConfiguration, hikariPoolDataSourceMetadataProvider, 
    org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration, 
    org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration, spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties, 
    org.springframework.cloud.autoconfigure.RefreshAutoConfiguration$RefreshScopeBeanDefinitionEnhancer, 
    org.springframework.cloud.autoconfigure.RefreshAutoConfiguration$JpaInvokerConfiguration, 
    org.springframework.cloud.autoconfigure.RefreshAutoConfiguration, refreshScope, loggingRebinder, configDataContextRefresher, refreshEventListener, 
    spring.cloud.refresh-org.springframework.cloud.autoconfigure.RefreshAutoConfiguration$RefreshProperties, 
    
    // JPA 관련 빈들
    org.springframework.data.jpa.domain.support.AuditingEntityListener, org.springframework.data.jpa.domain.support.AuditingBeanFactoryPostProcessor, 
    org.springframework.boot.autoconfigure.orm.jpa.JpaBaseConfiguration$JpaWebConfiguration, openEntityManagerInViewInterceptor, 
    openEntityManagerInViewInterceptorConfigurer, org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaConfiguration, 
    transactionManager, jpaVendorAdapter, entityManagerFactoryBuilder, entityManagerFactory, 
    spring.jpa.hibernate-org.springframework.boot.autoconfigure.orm.jpa.HibernateProperties, 
    spring.jpa-org.springframework.boot.autoconfigure.orm.jpa.JpaProperties, 
    org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration, 
    org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration, lettuceClientResources, 
    org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration, stringRedisTemplate, 
    spring.redis-org.springframework.boot.autoconfigure.data.redis.RedisProperties, 
    org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration, 
    org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration, lifecycleProcessor, 
    spring.lifecycle-org.springframework.boot.autoconfigure.context.LifecycleProperties, 
    org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration, persistenceExceptionTranslationPostProcessor, 
    org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration, emBeanDefinitionRegistrarPostProcessor, jpaContext, 
    org.springframework.data.jpa.util.JpaMetamodelCacheCleanup, org.springframework.data.jpa.repository.support.JpaEvaluationContextExtension, 
    commentRepositoryImpl, commentRepository, artistRepository, orderRepository, ticketRepository, userRepository, eventRepository, orderDetailRepository, 
    
    // Redis 설정 빈들
    org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration, 
    org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration, userTicketEntranceRedisRepository, 
    
    // Gson, Jackson, HttpMessageConverter, ArgumentResolver
    org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration, gsonBuilder, gson, standardGsonBuilderCustomizer, 
    spring.gson-org.springframework.boot.autoconfigure.gson.GsonProperties, 
    org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration$StringHttpMessageConverterConfiguration, stringHttpMessageConverter, 
    org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration$MappingJackson2HttpMessageConverterConfiguration, 
    mappingJackson2HttpMessageConverter, org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration, 
    org.springframework.boot.autoconfigure.http.GsonHttpMessageConvertersConfiguration, 
    org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration, messageConverters, 
    org.springframework.data.web.config.ProjectingArgumentResolverRegistrar, projectingArgumentResolverBeanPostProcessor, 
    
    // DB 접근 기술
    org.springframework.data.web.config.SpringDataWebConfiguration, pageableResolver, sortResolver, 
    org.springframework.data.web.config.SpringDataJacksonConfiguration, jacksonGeoModule, 
    org.springframework.data.web.config.QuerydslWebConfiguration, querydslPredicateArgumentResolver, querydslBindingsFactory, 
    org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration, pageableCustomizer, sortCustomizer, 
    spring.data.web-org.springframework.boot.autoconfigure.data.web.SpringDataWebProperties, 
    org.springframework.boot.autoconfigure.jdbc.JdbcTemplateConfiguration, jdbcTemplate, 
    org.springframework.boot.autoconfigure.jdbc.NamedParameterJdbcTemplateConfiguration, namedParameterJdbcTemplate, 
    org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration, spring.jdbc-org.springframework.boot.autoconfigure.jdbc.JdbcProperties, 
    org.springframework.boot.sql.init.dependency.DatabaseInitializationDependencyConfigurer$DependsOnDatabaseInitializationPostProcessor, 
    org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration, h2Console, spring.h2.console-org.springframework.boot.autoconfigure.h2.H2ConsoleProperties, 
    org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration, spring.info-org.springframework.boot.autoconfigure.info.ProjectInfoProperties, 
    org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration, 
    
    //  Netty
    org.springframework.boot.autoconfigure.netty.NettyAutoConfiguration, spring.netty-org.springframework.boot.autoconfigure.netty.NettyProperties, 
    org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration, 
    spring.security-org.springframework.boot.autoconfigure.security.SecurityProperties, 
    org.springframework.boot.autoconfigure.security.servlet.SpringBootWebSecurityConfiguration$ErrorPageSecurityFilterConfiguration, errorPageSecurityFilter, 
    org.springframework.boot.autoconfigure.security.servlet.SpringBootWebSecurityConfiguration, 
    org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration, authenticationEventPublisher, 
    org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration, securityFilterChainRegistration, 
    org.springframework.boot.autoconfigure.sql.init.DataSourceInitializationConfiguration, dataSourceScriptDatabaseInitializer, 
    
    // SQL 관련 설정
    org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration, 
    spring.sql.init-org.springframework.boot.autoconfigure.sql.init.SqlInitializationProperties, 
    org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration, taskScheduler, scheduledBeanLazyInitializationExcludeFilter, 
    taskSchedulerBuilder, spring.task.scheduling-org.springframework.boot.autoconfigure.task.TaskSchedulingProperties, 
    org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration$JdbcTransactionManagerConfiguration,
     
    // Transaction 담당 빈들
    org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration,
    org.springframework.transaction.config.internalTransactionAdvisor, transactionAttributeSource, transactionInterceptor, 
    org.springframework.transaction.config.internalTransactionalEventListenerFactory, 
    org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration$EnableTransactionManagementConfiguration$CglibAutoProxyConfiguration, 
    org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration$EnableTransactionManagementConfiguration, 
    org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration$TransactionTemplateConfiguration, 
    transactionTemplate, org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration, platformTransactionManagerCustomizers, 
    spring.transaction-org.springframework.boot.autoconfigure.transaction.TransactionProperties, 
    org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration, restTemplateBuilderConfigurer, restTemplateBuilder, 
    
    // WebServer 관련 빈들
    org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration$NettyWebServerFactoryCustomizerConfiguration, nettyWebServerFactoryCustomizer, 
    org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration$TomcatWebServerFactoryCustomizerConfiguration, tomcatWebServerFactoryCustomizer, 
    org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration, 
    
    // Reactor 관련 빈들
    org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorConfiguration$ReactorNetty, reactorClientResourceFactory, reactorClientHttpConnector, 
    org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration, clientConnectorCustomizer, 
    org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration$WebClientCodecsConfiguration, exchangeStrategiesCustomizer, 
    org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration, webClientBuilder, 
    
    org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration, characterEncodingFilter, localeCharsetMappingsCustomizer, 
    org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration, multipartConfigElement, multipartResolver, 
    spring.servlet.multipart-org.springframework.boot.autoconfigure.web.servlet.MultipartProperties, 
    org.springframework.boot.devtools.autoconfigure.DevToolsDataSourceAutoConfiguration$DatabaseShutdownExecutorEntityManagerFactoryDependsOnPostProcessor, 
    org.springframework.boot.devtools.autoconfigure.DevToolsDataSourceAutoConfiguration, inMemoryDatabaseShutdownExecutor, 
    org.springframework.boot.devtools.autoconfigure.LocalDevToolsAutoConfiguration$RestartConfiguration, restartingClassPathChangedEventListener, 
    classPathFileSystemWatcher, classPathRestartStrategy, fileSystemWatcherFactory, conditionEvaluationDeltaLoggingListener, 
    org.springframework.boot.devtools.autoconfigure.LocalDevToolsAutoConfiguration$LiveReloadConfiguration, liveReloadServer, 
    optionalLiveReloadServer, liveReloadServerEventListener, org.springframework.boot.devtools.autoconfigure.LocalDevToolsAutoConfiguration, 
    spring.devtools-org.springframework.boot.devtools.autoconfigure.DevToolsProperties, 
    
    org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration, configurationPropertiesBeans, configurationPropertiesRebinder, 
    org.springframework.cloud.autoconfigure.LifecycleMvcEndpointAutoConfiguration, environmentManager, 
    springfox.documentation.schema.configuration.ModelsConfiguration, typeResolver, modelBuilderPluginRegistry, modelPropertyBuilderPluginRegistry, 
    typeNameProviderPluginRegistry, syntheticModelProviderPluginRegistry, viewProviderPluginRegistry, 
    
    // Swagger 관련 빈들
    springfox.documentation.spring.web.SpringfoxWebConfiguration, defaults, resourceGroupCache, jsonSerializer, descriptionResolver, methodResolver, 
    pathProvider, documentationPluginRegistry, apiListingBuilderPluginRegistry, operationBuilderPluginRegistry, parameterBuilderPluginRegistry, 
    responseBuilderPluginRegistry, expandedParameterBuilderPluginRegistry, operationModelsProviderPluginRegistry, defaultsProviderPluginRegistry, 
    pathDecoratorRegistry, apiListingScannerPluginRegistry, modelNamesRegistryFactoryPluginRegistry, 
    springfox.documentation.spring.web.SpringfoxWebMvcConfiguration, webMvcObjectMapperConfigurer, 
    springfox.documentation.swagger.configuration.SwaggerCommonConfiguration, 
    springfox.documentation.oas.configuration.OpenApiMappingConfiguration, openApiModule, 
    springfox.documentation.oas.configuration.OpenApiWebMvcConfiguration, webMvcOpenApiTransformer, webMvcOpenApiTransformationFilterRegistry, 
    springfox.documentation.oas.configuration.OpenApiDocumentationConfiguration, 
    springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration, expanderMinMax, expanderNotNull, expanderNotBlank, 
    expanderPattern, expanderSize, parameterMinMax, parameterNotNull, parameterNotBlank, parameterPattern, parameterSize, minMaxPlugin, 
    decimalMinMaxPlugin, sizePlugin, isNullPlugin, notNullPlugin, notBlankPlugin, patternPlugin, 
    springfox.documentation.swagger2.configuration.Swagger2WebMvcConfiguration, webMvcSwaggerTransformer, 
    webMvcSwaggerTransformationFilterRegistry, springfox.documentation.swagger2.configuration.Swagger2DocumentationConfiguration, 
    swagger2Module, springfox.boot.starter.autoconfigure.SwaggerUiWebMvcConfiguration, swaggerUiConfigurer, 
    springfox.boot.starter.autoconfigure.OpenApiAutoConfiguration, springfox.documentation-springfox.boot.starter.autoconfigure.SpringfoxConfigurationProperties, 
    org.springframework.orm.jpa.SharedEntityManagerCreator#0
    
    ]; root of factory hierarchy
    ```

8. Thread에서 (아마 Main이겠죠?) run() 시켜버림
    - Reflection Method invoke로 실행시켜버림! -> 드디어 구동!
    ```java
    @Override
    public void run() {
        try {
            Class<?> mainClass = Class.forName(this.mainClassName, false, getContextClassLoader());
            Method mainMethod = mainClass.getDeclaredMethod("main", String[].class);
            mainMethod.invoke(null, new Object[] { this.args });
        }
        catch (Throwable ex) {
            this.error = ex;
            getUncaughtExceptionHandler().uncaughtException(this, ex);
        }
    }
    ```

## 시큐리티 인가 과정 디버거와 함께

## 트랜잭션 수행 디버거와 함께

## Spring은 항상 CGLIB을 쓸까?
- *참고: https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch08s06.html*
- *참고: https://stackoverflow.com/questions/68084650/why-does-spring-inject-some-of-my-dependencies-as-cglib-proxies-and-why-are-the*
- Spring AOP는 JDK dynamic proxy 혹은 CGLIB 프록시를 통해 프록시를 생성한다. 
  - JDK dynamic proxy를 통해 프록시를 만들 수 있다면 이걸로 우선적으로 만드려 한다. 
  - 타겟 객체가 하나의 인터페이스라도 구현하고 있다면, JDK dynamic proxy가 생성될 것
  - 만약 인터페이스로 구현을 해둔게 없다면 CGLIB으로 프록시화 할 것
- 물론 CGLIB으로 싹다 프록시화 시킬 수 있음. 하지만 다음을 유념할 것
  - final은 재정의 할 수 없기에 AOP 도입 못함
  - CGLIB 라이브러리가 꼭 필요합니다
  - 프록시 객체의 생성자는 2번 호출됨. 프록시화된 객체에 대한 서브클래스가 생성되는 과정에서 어쩔 수 없음
    - 프록시화 된 객체는 2개가 각각 생성됨. 
    - JDK는 이게 2번 호출 안됨. 
      - 생성자에 로직 없으면 큰 문제 안됨

## JDK Dynamic Proxy
- 공통으로 처리할 전/후처리 로직을 **InvocationHandler**로 구현하여 인터페이스를 구현할 때 사용하도록 하자
    ```java
    AInterface target = new AImpl();
    // JDK 동적 프록시의 InvocationHandler를 구현한 구현체로, 
    // target 객체의 메서드 수행 전/후처리에 대한 로직을 담아둔다 
    TimeInvocationHandler handler = new TimeInvocationHandler(target);
    // AInterface 타입으로 프록시를 만든다
    // 따라서 실 구현체와는 아무런 연관이 없는 프록시가 생성이 된다
    // 그저 각 메서드 호출시 필요한 전/후처리를 담은 핸들러만 전달
    AInterface proxy = (AInterface) Proxy.newProxyInstance(AInterface.class.getClassLoader(), new Class[]{AInterface.class}, handler);
    proxy.call();
    ```
- 스프링에서 사용하는 jdk - getProxy() 메서드
    ```java
    public JdkDynamicAopProxy(AdvisedSupport config) throws AopConfigException {
        Assert.notNull(config, "AdvisedSupport must not be null");
        if (config.getAdvisorCount() == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {
            throw new AopConfigException("No advisors and no TargetSource specified");
        }
        this.advised = config;
        this.proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
        findDefinedEqualsAndHashCodeMethods(this.proxiedInterfaces);
    }
    
    @Override
    public Object getProxy() {
        return getProxy(ClassUtils.getDefaultClassLoader());
    }
    
    @Override
    public Object getProxy(@Nullable ClassLoader classLoader) {
        if (logger.isTraceEnabled()) {
            logger.trace("Creating JDK dynamic proxy: " + this.advised.getTargetSource());
        }
        return Proxy.newProxyInstance(classLoader, this.proxiedInterfaces, this);
    }
    ```

## CGLIB
- 공통으로 처리할 전/후처리 로직을 **MethodInterceptor**로 구현하여 프록시 메서드 수행시 사용하도록 하자
    ```java
    ConcreteService target = new ConcreteService();
    // CGLIB는 enhancer를 통한 프록시를 생성한다
    Enhancer enhancer = new Enhancer();
    // 상속받을 구체 클래스를 지정한다. 
    enhancer.setSuperclass(ConcreteService.class); 
    // CGLIB은 MethodInterceptor를 통해 프록시에 적용할 실행 로직을 할당
    enhancer.setCallback(new TimeMethodInterceptor());
    // 지정한 콘크리트 클래스를 상속받아 프록시를 생성한다. 
    ConcreteService proxy = (ConcreteService) enhancer.create();
    proxy.call();
    ```
- 스프링에서 사용하는 cglib - getProxy() 메서드
    ```java
    @Override
    public Object getProxy(@Nullable ClassLoader classLoader) {
        if (logger.isTraceEnabled()) {
            logger.trace("Creating CGLIB proxy: " + this.advised.getTargetSource());
        }
    
        try {
            Class<?> rootClass = this.advised.getTargetClass();
            Assert.state(rootClass != null, "Target class must be available for creating a CGLIB proxy");
    
            Class<?> proxySuperClass = rootClass;
            if (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) {
                proxySuperClass = rootClass.getSuperclass();
                Class<?>[] additionalInterfaces = rootClass.getInterfaces();
                for (Class<?> additionalInterface : additionalInterfaces) {
                    this.advised.addInterface(additionalInterface);
                }
            }
    
            validateClassIfNecessary(proxySuperClass, classLoader);
    
            // Configure CGLIB Enhancer...
            Enhancer enhancer = createEnhancer();
            if (classLoader != null) {
                enhancer.setClassLoader(classLoader);
                if (classLoader instanceof SmartClassLoader &&
                        ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) {
                    enhancer.setUseCache(false);
                }
            }
            enhancer.setSuperclass(proxySuperClass);
            enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
            enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
            enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(classLoader));
    
            // Callback 구현을 통한 인터셉터 등록
            Callback[] callbacks = getCallbacks(rootClass);
            Class<?>[] types = new Class<?>[callbacks.length];
            for (int x = 0; x < types.length; x++) {
                types[x] = callbacks[x].getClass();
            }
            enhancer.setCallbackFilter(new ProxyCallbackFilter(
                    this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));
            enhancer.setCallbackTypes(types);
    
            return createProxyClassAndInstance(enhancer, callbacks);
        }
        catch (CodeGenerationException | IllegalArgumentException ex) {
            throw new AopConfigException("Could not generate CGLIB subclass of " + this.advised.getTargetClass() +
                    ": Common causes of this problem include using a final class or a non-visible class",
                    ex);
        }
        catch (Throwable ex) {
            // TargetSource.getTarget() failed
            throw new AopConfigException("Unexpected AOP exception", ex);
        }
    }
    ```

## DefaultAopProxyFactory
- DefaultAopProxyFactory로 기본적으로 프록시화를 시키네!
    ```java
    public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {
    
        private static final long serialVersionUID = 7930414337282325166L;
    
        @Override
        public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
            if (!NativeDetector.inNativeImage() &&
                    (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) {
                Class<?> targetClass = config.getTargetClass();
                if (targetClass == null) {
                    throw new AopConfigException("TargetSource cannot determine target class: " +
                            "Either an interface or a target is required for proxy creation.");
                }
                // 타겟 클래스가 인터페이스 있으면 => Jdk
                if (targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass)) {
                    return new JdkDynamicAopProxy(config);
                }
                // 없으면 CGLIB
                return new ObjenesisCglibAopProxy(config);
            }
            else {
                return new JdkDynamicAopProxy(config);
            }
        }
    
        private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {
            Class<?>[] ifcs = config.getProxiedInterfaces();
            return (ifcs.length == 0 || (ifcs.length == 1 && SpringProxy.class.isAssignableFrom(ifcs[0])));
        }
    }
    ```
