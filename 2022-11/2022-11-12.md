### 2022-11-12

## 빈 스코프
- *참고: https://velog.io/@probsno/Bean-%EC%8A%A4%EC%BD%94%ED%94%84%EB%9E%80*
- **정의**
  - 빈이 사용되어지는 범위

- **빈 스코프 종류**
  - Singleton : 스프링 IoC 컨테이너당 하나의 인스턴스만 사용
  - Prototype : 매번 새로운 빈을 정의하여 사용
  - Request : HTTP 라이프사이클 마다 한 개의 빈을 사용
  - Session : HTTP 세션마다 한 개의 빈을 사용
  - Application : ServletContext 라이프사이클 동안 한 개의 빈을 사용
  - Websocket : Websocket 라이프사이클 안에서 한 개의 빈을 사용

- **Prototype 스코프를 사용하는 방법**
  - 정의하는 법
    ```java
    @Component
    @Scope(value = "prototype")
    public class ProtoType {
    }
    ```
  - 근데... 싱글톤 빈의 컴포넌트로 Prototype 스코프 빈을 쓰면 어쩌지? 
    - 싱글톤 스코프의 빈이 프로토타입 빈을 주입받으면 싱글톤 프로토타입 빈은 매번 바뀌지 않고 같은 빈이 쓰임
    ```java
    @Component
    public class Single {
        @Autowired
        ProtoType protoType;
    }
    
    @Component
    @Scope(value = "prototype")
    public class ProtoType {
    }
    ```
  - 프록시 모드로 해결하기!
    - ApplicationContext가 빈을 처음 생성시, proto 빈을 주입받지 않고,
    - proto 클래스 상속받은 프록시를 빈으로 등록해
    - 프록시에서 내부적으로 매번 새로운 proto 빈을 사용하게 끔 설계됨
    ```java
    @Component
    @Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
    public class ProtoType {
    }
    ```

## 스프링 사용자들의 주입 방식
- *참고: https://velog.io/@sh95119/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%82%AC%EC%9A%A9%EC%9E%90%EB%93%A4%EC%9D%B4-%EC%84%A0%ED%98%B8%ED%95%98%EB%8A%94-%EC%A3%BC%EC%9E%85-%EB%B0%A9%EC%8B%9D*
- **생성자로 주입하자**
  - 순환참조 방지
  - 테스트에 용이
  - 클린한 코드 유지
  - 불변성 보장 가능

## `@ComponentScan`
- *참고: https://velog.io/@hyun-jii/%EC%8A%A4%ED%94%84%EB%A7%81-component-scan-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95*
- *참고: https://jjingho.tistory.com/9*
- **정의**
  - 빈으로 등록될 준비를 마친 클래스들을 스캔하여, 빈으로 등록해주는 것
  - `@Component`가 붙은 클래스들이 빈으로 등록 대상이 된다

- **ComponentScan 하는 방법**
  1. xml 파일에 설정
     - `<context:component-scan base-package="com.rcod.lifelog"/>`
     - base package 기준으로 클래스들을 스캔하여 빈으로 등록 가능
     - include-filter, exclude-filter 등을 통해 특정 객체 포함/제외 설정 가능
  2. 자바 파일 안에서 설정
    - 특정 패키지를 basePackage로 잡고 ComponentScan을 통한 빈 등록
    ```java
    @Configuration
    @ComponentScan(basePackages = "com.rcod.lifelog")
    public class ApplicationConfig {
    }
    ```

- **ComponentScan 동작 과정**
  1. ConfigurationClassParser가 `@Configuration` 클래스를 파싱
  2. ComponentScan 설정을 파싱
     - base-package에 명시된 패키지를 기준으로 ComponentScanAnnotationParser가 스캔하기 위한 설정 파싱
  3. base-pacakge 설정을 바탕으로 모든 클래스를 로딩
  4. ClassLoader가 로딩한 클래스들을 BeanDefinition으로 정의
  5. 생성할 빈에 대한 정의를 토대로 빈 생성

- **ComponentScan 동작 원리**
  - `@ComponentScan`은 **BeanFactoryPostProcessor**를 구현한 **ConfigurationClassPostProcessor**에 의해 동작
  - 컴포넌트 스캔을 해서 Bean으로 등록해줌
  - vs `@Autowired`
    - `@Autowired`는 등록된 다른 Bean을 찾아 BeanPostProcessor의 구현체를 적용해 의존성 주입을 적용함
    - `@ComponentScan`은 다른 Bean들을 찾아 BeanFactoryPostProcessor의 구현체를 적용해 Bean을 등록시켜줌
