### 2022-11-12

## 빈 스코프
- *참고: https://velog.io/@probsno/Bean-%EC%8A%A4%EC%BD%94%ED%94%84%EB%9E%80*
- **정의**
  - 빈이 사용되어지는 범위

- **빈 스코프 종류**
  - Singleton : 스프링 IoC 컨테이너당 하나의 인스턴스만 사용
  - Prototype : 매번 새로운 빈을 정의하여 사용
  - Request : HTTP 라이프사이클 마다 한 개의 빈을 사용
  - Session : HTTP 세션마다 한 개의 빈을 사용
  - Application : ServletContext 라이프사이클 동안 한 개의 빈을 사용
  - Websocket : Websocket 라이프사이클 안에서 한 개의 빈을 사용

- **Prototype 스코프를 사용하는 방법**
  - 정의하는 법
    ```java
    @Component
    @Scope(value = "prototype")
    public class ProtoType {
    }
    ```
  - 근데... 싱글톤 빈의 컴포넌트로 Prototype 스코프 빈을 쓰면 어쩌지? 
    - 싱글톤 스코프의 빈이 프로토타입 빈을 주입받으면 싱글톤 프로토타입 빈은 매번 바뀌지 않고 같은 빈이 쓰임
    ```java
    @Component
    public class Single {
        @Autowired
        ProtoType protoType;
    }
    
    @Component
    @Scope(value = "prototype")
    public class ProtoType {
    }
    ```
  - 프록시 모드로 해결하기!
    - ApplicationContext가 빈을 처음 생성시, proto 빈을 주입받지 않고,
    - proto 클래스 상속받은 프록시를 빈으로 등록해
    - 프록시에서 내부적으로 매번 새로운 proto 빈을 사용하게 끔 설계됨
    ```java
    @Component
    @Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
    public class ProtoType {
    }
    ```

## 스프링 사용자들의 주입 방식
- *참고: https://velog.io/@sh95119/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%82%AC%EC%9A%A9%EC%9E%90%EB%93%A4%EC%9D%B4-%EC%84%A0%ED%98%B8%ED%95%98%EB%8A%94-%EC%A3%BC%EC%9E%85-%EB%B0%A9%EC%8B%9D*
- **생성자로 주입하자**
  - 순환참조 방지
  - 테스트에 용이
  - 클린한 코드 유지
  - 불변성 보장 가능

## `@ComponentScan`
- *참고: https://velog.io/@hyun-jii/%EC%8A%A4%ED%94%84%EB%A7%81-component-scan-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95*
- *참고: https://jjingho.tistory.com/9*
- **정의**
  - 빈으로 등록될 준비를 마친 클래스들을 스캔하여, 빈으로 등록해주는 것
  - `@Component`가 붙은 클래스들이 빈으로 등록 대상이 된다

- **ComponentScan 하는 방법**
  1. xml 파일에 설정
     - `<context:component-scan base-package="com.rcod.lifelog"/>`
     - base package 기준으로 클래스들을 스캔하여 빈으로 등록 가능
     - include-filter, exclude-filter 등을 통해 특정 객체 포함/제외 설정 가능
  2. 자바 파일 안에서 설정
    - 특정 패키지를 basePackage로 잡고 ComponentScan을 통한 빈 등록
    ```java
    @Configuration
    @ComponentScan(basePackages = "com.rcod.lifelog")
    public class ApplicationConfig {
    }
    ```

- **ComponentScan 동작 과정**
  1. ConfigurationClassParser가 `@Configuration` 클래스를 파싱
  2. ComponentScan 설정을 파싱
     - base-package에 명시된 패키지를 기준으로 ComponentScanAnnotationParser가 스캔하기 위한 설정 파싱
  3. base-pacakge 설정을 바탕으로 모든 클래스를 로딩
  4. ClassLoader가 로딩한 클래스들을 BeanDefinition으로 정의
  5. 생성할 빈에 대한 정의를 토대로 빈 생성

- **ComponentScan 동작 원리**
  - `@ComponentScan`은 **BeanFactoryPostProcessor**를 구현한 **ConfigurationClassPostProcessor**에 의해 동작
  - 컴포넌트 스캔을 해서 Bean으로 등록해줌
  - vs `@Autowired`
    - `@Autowired`는 등록된 다른 Bean을 찾아 BeanPostProcessor의 구현체를 적용해 의존성 주입을 적용함
    - `@ComponentScan`은 다른 Bean들을 찾아 BeanFactoryPostProcessor의 구현체를 적용해 Bean을 등록시켜줌

## 어플리케이션 컨텍스트
- *참고: https://mangkyu.tistory.com/151*
- **어플리케이션 컨텍스트**
  - 빈의 생성과 관계 설정 등의 제어를 담당하는 IoC 컨테이너인 빈 팩토리가 존재
  - 빈의 생성/관계 설정 외에 추가적인 기능이 필요! Spring에서는 빈 팩토리를 상속받아 확장한 **어플리케이션 컨텍스트**를 사용함
  - 어플리케이션 컨텍스트는...
    - 별도의 설정 정보 참고
    - IoC 적용하여 빈의 생성, 관계 설정 등의 제어 작업 총괄
    - 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 없고, 그런 생성 정보와 연관관계 정보에 대한 설정을 읽어 처리함
  - **생성 정보, 연관관계 정보에 대한 설정을 참고**하여 처리함 => `@Configuration`

- **클라이언트의 Bean 요청 시 처리 과정**
  1. ApplicationContext는 `@Configuration`이 붙은 클래스를 설정 정보로 등록해두고, `@Bean`이 붙은 메서드의 이름으로 빈 목록 생성
  2. 클라이언트가 해당 빈 요청
  3. ApplicationContext는 자신의 빈 목록에서 요청한 이름이 있는지 찾음
  4. ApplicationContext는 설정 클래스로부터 빈 생성을 요청, 생성된 빈을 돌려줌

- **어플리케이션 컨텍스트의 장점**
  - 클라이언트는 `@Configuration`이 붙은 구체적인 팩토리 클래스를 알 필요가 없음
    - 원하는 객체를 가져오려면 어떤 팩토리 클래스에 접근해야 하는지 알아야하는데...
    - 어플리케이션 컨텍스트를 사용하면 팩토리가 아무리 많아져도 직접 접근할 필요 X
  - 어플리케이션 컨텍스트는 종합 IoC 서비스를 제공해줌
    - 객체 생성과 관계 설정이 전부가 아님... 
    - 객체가 만들어지는 방식/시점/전략 등을 다르게 가져갈 수 있고,
    - 그 외에도 후처리나 정보의 조합 인터셉트 등과 같은 다양한 기능이 존재
  - 어플리케이션 컨텍스트를 통한 다양한 빈 검색 방법을 제공할 수 있음
    - 어플리케이션 컨텍스트에서 빈 목록을 관리하여 빈의 이름이나 타입, 어노테이션 설정 등으로 빈을 찾을 수 있음
    - dependency lookup!

- **Spring에서의 Singleton**
  - Spring에서 싱글톤
    - 여러번 빈을 요청하더라도 매번 동일한 객체
    - 대규모 트래픽 처리할 수 있도록 하기 위함
      - 대규모 트래픽 처리하려고 Controller, Service, Repository 등 나뉘게 됨
    - 매번 클라이언트에서 요청이 올 때 마다 빈 새로 만들면 부하 감당 빡셈
    - 빈을 싱글톤 스코프로 관리하여 1개의 요청 왔을 때 여러 쓰레드가 빈을 공유해 처리하도록 하였음

- **Spring Singleton vs Java Singleton**
  - Java Singleton의 단점
    - private 생성자를 가져 상속이 불가능
    - 테스트하기 힘듦
    - 서버 환경에서는 싱글톤이 1개만 생성됨을 보장하지 못함
    - 전역 상태를 만들 수 있기에 객체지향적이지 못함
  - Spring은 직접 싱글톤 형태의 오브젝트 만들고 관리하는 기능을 제공 => 싱글톤 레지스트리
    - 싱글톤 생성하고, 관리하고, 공급하는 컨테이너
    - static 메서드나 private 생성자 등을 사용하지 않아 객체지향적 개발을 할 수 있음
    - 테스트 하기 편함!
  - Spring singleton은 내부에 상태를 갖지 않는 무상태 방식으로 만들 것!
