### 2023-03-20

## Scala 코드리뷰
- **Future를 다루는 방법?**
- **Controller의 Action은 무슨 용도인가?**
- **찐으로 랜덤한 13자리 숫자를 만드는 방법은?**
- **Action.async는 뭐하는 친구일까?**

## Action
- *참고: https://www.playframework.com/documentation/2.8.x/ScalaActions*
- **개요**
  - `play.api.mvc.Action`은 `play.api.mvc.Request => play.api.mvc.Result` 함수를 나타낸다
    - request를 처리해 result를 만든다는 뜻
  - **컨트롤러는 그저 Action 생성기임을 기억해주세용**

- **Action 만들기**
  - BaseController를 extend한 컨트롤러의 경우, Action이 기본 탑재되어 있음
  - 여러가지 Action 빌더들을 통해 Action을 생성할 수 있음

- **예시 1. Request 참조 없이**
  - 가장 간단한 방법 중에 하나
  - 하지만 incoming request에 대한 참조를 얻을 수 없다
    ```
    Action {
        OK("Hello World")
    }
    ```

- **예시 2. Request => Result**
  - `Request => Result`를 아규먼트로 받아 반환하는 친구가 있음
    ```scala
    Action { request => 
        Ok("Got Request [ " + request + "]")
    }
    ```
  - 여기서 request를 implicit으로 받으면, 다른 API에서 받아서 처리할 수 있음
    ```scala
    Action { implicit request =>
        Ok("Got Request [ " + request + "]")
    }
    
    def action = Action { implicit request =>
        anotherMethod("Some para value")
        Ok("Got Request [ " + request + "]")
    }
    
    def anotherMethod(p: String)(implicit request: Request[_]) = {
        // do sth that needs access
    }
    ```

- **예시 3. additional BodyParser**
  - 다른 BodyParser 기능을 통해 Action 객체를 만들수 있나봄
  - 현재로썬 그냥 Any content body parser가 있나보다~
    ```scala
    Action(parse.json) { implicit request =>
        Ok("Got request [ " + request + "]")
    }
    ```

- **Simple Results**
    ```scala
    def index = Action {
        Result(
            header = ResponseHeader(200, Map.empty),
            body = HttpEntity.Strict(ByteString("Hello world!"), Some("text/plain"))
        )
    }
    
    // 위에꺼랑 아래꺼랑 똑같아
    def index = Action {
        Ok("Hello World!")
    }
    
    val ok           = Ok("Hello world!")
    val notFound     = NotFound
    val pageNotFound = NotFound(<h1>Page not found</h1>)
    val badRequest   = BadRequest(views.html.form(formWithErrors))
    val oops         = InternalServerError("Oops")
    val anyStatus    = Status(488)("Strange response type")
    ```
  
- **Redirect도 그저 간단한 Result 일 뿐**
    ```scala
    def index = Action {
      Redirect("/user/home")
    }
    
    def index = Action {
        Redirect("/user/home", MOVED_PERMANENTLY)
    }
    ```
  
## Action.async
- **개요**
  - 비동기적으로 다른 쓰레드 풀에서 non-blocking 코드를 실행하도록 지원함
    - 따라서 해당 코드가 long-run operation에 들어가더라도, 서버는 다른 incoming request 처리가 가능하다

- **클라이언트에게 응답이 어떻게 가능하지?**
  - `Action.async`는 `Future[Result]`를 반환한다
  - `Action.async`가 있다면, 플레이가 Http request를 받는 쓰레드가 아닌, 다른 쓰레드에 해당 function 수행을 매핑시켜 실행시킬 거임
    - `Future[Result]`가 완료된다면, 플레이는 Http request를 통해 클라이언트에게 해당 응답을 줄 수 있도록 할 것임

- **예시**
    ```scala
    def delayResponse: Action[AnyContent] = Action.async {
        Akka.system.scheduler.scheduleOnce(1.second) {
            Future.successful(Ok("Response after 1 second delay!"))
        }
    }
    ```
  
- **Action.async vs Action**
  - 시간을 많이 잡아먹는 작업이 request를 받는 thread에서 수행된다면 => Action.async가 좋음
  - 다만, `Action.async`에는 단점이 있어서 필요할 때만 사용하는 것도 좋아보인다. 
    - `Future`를 관리하는 비용
    - 쓰레드풀 관리 비용
  - 벤치마크 확인하고, 코드 프로파일링하고, 병목/최적화 하는 것이 좋아보임
