### 2023-12-15

## JS 모듈 시스템 - CJS, AMD, UMD, ESM
*참고: https://beomy.github.io/tech/javascript/cjs-amd-umd-esm/*
*참고: https://betterprogramming.pub/what-are-cjs-amd-umd-esm-system-and-iife-3633a112db62*
- **개요**
  - 현대 JS 프로젝트는 번들러를 통해서 작은 조각의 코드를 하나의 뭉텅이로 뭉쳐서 내보내야 함 (라이브러리/어플리케이션 구축)
    - webpack, Rollup, Parcel, RequireJS, Browserify
  - JS 모듈을 가져오거나 내보내는 방법이 없었음 => 하나의 파일에 모든 기능들이 들어가야 함
  - CJS,AMD,UMD,ESM이 등장 후에 모듈로 개발/배포할 수 있게 됨

- **번들러** 
  - 하나의 파일로 뭉텅이 지어서 사용하는것은 간단한 경우에는 괜찮은데...
    - 프로젝트가 확장될 수록, 우리는 모듈화의 니즈가 커짐 (별도의 namespace, 캡슐화, 의존성관리, 재사용 등)
  - 이때 번들러가 필요해짐
    - css, 이미지 등등
  - 번들러가 코드를 어떤 형식으로 내보낼지 정의하게 됨
    - `cjs`: node 혹은 타 번들러에 적합
    - `amd`: RequireJS와 같은 모듈 로더와 함께 쓰임
    - `umd`: `amd`, `cjs`, `iife` 올인원으로 쓰임
    - `es`/`esm`: ES 모듈 파일 `<script type=module>` 태그임
    - `system`: SystemJS에서 Native Format
    - `iife`: Self Executing Function

- **CJS (CommonJS)**
  - CommonJS: JS를 브라우저뿐만이 아니라 범용언어로 사용하고자 만들어진 그룹
  - [코드 예제]
    ```js
    var lib = require('package/lib');
    
    function foo() {
        lib.log('hello world');
    }
    
    exports.foobar = foo;
    
    // ---
    var foo = require('foo');
    var bar = require('bar');
    foo.log('It is foo');
    bar.log('It is bar');
    ```
  - [특징]
    - 동기적으로 동작
    - 서버사이드에서 사용하기 용이함
    - Node.js가 CommonJS를 채택하여 사용 중

- **AMD (Asynchronous Module Definition)**
  - CommonJS는 모든 파일이 로컬디스크에 있어서 바로 불러올 수 있어야 해
  - 동기적으로 동작이 가능한 서버사이드 JS 환경을 전제로 함
  - 브라우저에서는 이게 다운 못 받으면 암것도 못하는 상황으로 치닫음
  - AMD는 브라우저 안에서의 동작을 중점을 둔 그룹임
  - [코드 예제]
    ```js
    define(['package/lib'], function(lib) {
        function foo() {
            lib.log('hello world');
        }
        
        return {
            foobar: foo
        };
    });
    
    require(['package/myModule'], function(myModule) {
        myModule.foobar();
    });
    ```
  - [특징]
    - 비동기
    - 네트워크를 통해 모듈을 내려받는 브라우저이기에, 비동기로 동작해야 함
    - 비동기적인 특징으로 클라이언트 사이드 개발에 용이

- **UMD (Universal Module Definition)**
  - AMD, CommonJS 호환을 위해 해결
    - AMD, CommonJS, window에 추가하는 방식까지 모두 가능한 모듈 작성 방식
  - 두 부분으로 구성됨
    - 모듈 로더를 확인하는 즉시 실행 함수(IIFE): 이 함수는 `root`(전역 범위)와 `factory`(모듈을 선언하는 함수) 2개의 파라미터 가짐
    - 모듈을 생성하는 익명 함수: 이 함수가 즉시 실행 함수의 2번째 파라미터로 넘어감
  - [코드 예제]
    ```js
    (function(root, factory) {
        if (typeof define === 'function' && define.amd) {
            // AMD
            define(['exports', 'b'], factory);
        } else if (typeof exports == 'object' && typeof exports.nodeName !== 'string') {
            // CommonJS
            factory(exports, require('b'));
        } else {
            // Browser globals
            factory((root.commonJsStrict = {}), root.b);
        }
    }(this, function (exports, b) {
        exports.action = function() {};
    }));
    ```
  - [특징]
    - 여러 모듈 로더에서 사용 가능
    - AMD/CommonJS 모두 사용가능

- **ESM (ECMAScript Module)**
  - ES6에 JS 모듈 기능이 추가됨
  - [코드 예제]
    ```js
    import lib from 'package/lib';
    
    function foo() {
        lib.log('hello world');
    }
    
    export { foobar: foo };
    ```
  - [특징]
    - ECMAScript에서 지원하는 JS 자체 모듈 시스템
    - 브라우저에서는 `import`, `export`를 지원하지 않아 번들러를 함께 사용해야 함
  - [부록]
    - `<script type="module" src="index.mjs">`
      - `type="module"` 선언하면 자바스크립트 파일은 모듈로 동작
      - 모듈이라는 것을 명확히 알기 위해 `mjs` 확장자를 사용하도록 권장
      - 해당 파일에 `import`, `export` 사용이 가능
      - `foo.mjs`, `bar.mjs` 파일의 window는 서로 공유되지 않음
        ```html
        <html lang="en">
        <body>
            <script type="module" src="foo.mjs"></script>
            <script type="module" src="bar.mjs"></script>
        </body>
        </html>
        ```

## IIFE (Immediately Invoked Function Expression)
*참고: https://developer.mozilla.org/ko/docs/Glossary/IIFE*
*참고: https://mine-it-record.tistory.com/339*
- **개요**
  - 정의되자마자 즉시 실행되는 JS Function

- **형식**
  - 크게 두 부분으로 나뉨
    1. Grouping Operator
      - () 안에 어휘 범위로 둘러싸인 익명함수. 
      - 전역 스코프에 불필요한 변수 추가해서 오염을 방지함. 
        - 스코프를 딱 요만큼안으로 제한
      - IIFE 안으로 다른 변수 접근 못하게 함.
    2. 즉시 실행함수를 생성하는 괄호
      - JS 엔진은 함수를 즉시 해석해서 실행
  ```js
  (function () {
      // ...
  })();
  
  (() => {
      // ...
  })();
  
  (async () => {
      // ...
  })();
  ```

- **언제 사용하지?**
  1. 코드 사이의 충돌을 예방 (스코프 제한)
  2. 전역 변수/전역 함수가 되지 않도록 방지
  3. 변수의 값을 즉시 할당

## Promise
